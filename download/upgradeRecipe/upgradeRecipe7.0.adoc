= Upgrade recipe 7.0
:awestruct-description: Upgrade to OptaPlanner 7.0 from a previous version.
:awestruct-layout: upgradeRecipeBase
:awestruct-priority: 0.5
:awestruct-upgrade_recipe_version: 7.0

== Backwards incompatible changes to the public API

Because this is a new major version number (7.0), which is the foundation for the 7.x series,
it allows us to make backwards incompatible changes to the public API for the long term benefit of this project.

Our current intention is to keep these backwards incompatible changes to a strict minimum
(by favoring deprecation over removal). Our current intention is also to work on the 7.x series for several years
(during which time we won't make backwards incompatible changes to the API).

[.upgrade-recipe-major]
=== Java 8 or higher required

If you're using JRE or JDK 6 or 7, upgrade to JDK 8 or higher.

We currently intend to support a minimal version of Java 8 throughout the entire 7.x series.

[.upgrade-recipe-minor]
===  `Solver`: return values no longer implement `Solution`

Because the `Solution` interface was deprecated (see the section below to upgrade from 6.4.0.Final to 7.0.0.Beta1),
the `Solver.solve(...)` and `Solver.getBestSolution()` methods now return an `Object` instead of a `Solution` instance
(if and only if no type parameter is specified for the `Solver`).

*This only applies if you're still using a `Solver` without a type parameter
and if you're not casting the return value immediately to your solution implementation (which is unlikely).*

Before in `*.java`:
[source, java]
----
Solution s = solver.solve(problem);
CloudBalance solution = (CloudBalance) s;
----

After in `*.java` (quick and dirty fix):
[source, java]
----
CloudBalance solution = (CloudBalance) solver.solve(problem);
----

After in `*.java` (recommended fix):
[source, java]
----
SolverFactory<CloudBalance> factory = SolverFactory.createFromXmlResource(...);
Solver<CloudBalance> solver = factory.buildSolver();
...
CloudBalance solution = solver.solve(problem);
----


[.upgrade-recipe-minor]
===  `BestSolutionChangedEvent.getNewBestSolution()`: return value no longer implement `Solution`

Because the `Solution` interface was deprecated (see the section below to upgrade from 6.4.0.Final to 7.0.0.Beta1),
the `BestSolutionChangedEvent.getNewBestSolution()` method now returns an `Object`
(if and only if no type parameter is specified for the `SolverEventListener`).

*This only applies if you're still using a `SolverEventListener` without a type parameter
and if you're not casting the return value immediately to your solution implementation (which is unlikely).*

Before in `*.java`:
[source, java]
----
SolverFactory factory = SolverFactory.createFromXmlResource(...);
Solver solver = factory.buildSolver();
solver.addEventListener(new SolverEventListener() {
    @Override
    public void bestSolutionChanged(BestSolutionChangedEvent event) {
        Solution s = event.getNewBestSolution();
        CloudBalance solution = (CloudBalance) s;
        ...
    }
});
----

After in `*.java`:
[source, java]
----
SolverFactory<CloudBalance> factory = SolverFactory.createFromXmlResource(...);
Solver<CloudBalance> solver = factory.buildSolver();
solver.addEventListener(new SolverEventListener<CloudBalance>() {
    @Override
    public void bestSolutionChanged(BestSolutionChangedEvent<CloudBalance> event) {
        CloudBalance solution = event.getNewBestSolution();
        ...
    }
});
----

And you'll probably want to use a lamdba here:

[source, java]
----
SolverFactory<CloudBalance> factory = SolverFactory.createFromXmlResource(...);
Solver<CloudBalance> solver = factory.buildSolver();
solver.addEventListener(event -> {
    CloudBalance solution = event.getNewBestSolution();
    ...
});
----

[.upgrade-recipe-minor]
===  Deprecated methods removed

The following long term deprecated methods have been finally removed:

* Setters on `ScoreHolder` implementations, such as `HardSoftScoreHolder`'s `setHardScore(int)` and `setSoftScore(int)`.
Use `addHardConstraintMatch(...)` and `addSoftConstraintMatch(...)` instead.

[.upgrade-recipe-readme]
=== Don't stop here

For usability and performance reasons, we strongly recommend to apply this entire upgrade recipe
to replace your use of any deprecated API's with the newer and better API's.

== From 6.4.0.Final to 7.0.0.Beta1

[.upgrade-recipe-major]
=== `Solution` interface removed (deprecated)

Your solution class no longer needs to have both the `@PlanningSolution` annotation and implement the `Solution` interface,
only the annotation suffices. The `Solution` interface has been deprecated and will be removed in a future version.

Remove the `Solution` interface, annotate the `getScore()` method with `@PlanningScore`
and replace the `getProblemFacts()` method with a `@ProblemFactCollectionProperty` annotation directly on every problem fact getter (or field).

Before in `*.java`:
[source, java]
----
@PlanningSolution
public class CloudBalance implements Solution<HardSoftScore> {

    private List<CloudComputer> computerList;
    ...

    private HardSoftScore score;

    @ValueRangeProvider(id = "computerRange")
    public List<CloudComputer> getComputerList() {...}

    public HardSoftScore getScore() {...}
    public void setScore(HardSoftScore score) {...}

    public Collection<? extends Object> getProblemFacts() {
        List<Object> facts = new ArrayList<Object>();
        facts.addAll(computerList);
        ...
        return facts;
    }

}
----

After in `*.java`:
[source, java]
----
@PlanningSolution
public class CloudBalance {

    private List<CloudComputer> computerList;
    ...

    private HardSoftScore score;

    @ValueRangeProvider(id = "computerRange")
    @ProblemFactCollectionProperty
    public List<CloudComputer> getComputerList() {...}

    @PlanningScore
    public HardSoftScore getScore() {...}
    public void setScore(HardSoftScore score) {...}

}
----

For a single problem fact (which is not wrapped in a `Collection`), use the `@ProblemFactProperty` annotation,
as shown below (with field annotations this time).

Before in `*.java`:
[source, java]
----
@PlanningSolution
public class CloudBalance implements Solution<HardSoftScore> {

    private CloudParametrization parametrization;
    private List<CloudBuilding> buildingList;
    @ValueRangeProvider(id = "computerRange")
    private List<CloudComputer> computerList;
    ...

    public Collection<? extends Object> getProblemFacts() {
        List<Object> facts = new ArrayList<Object>();
        facts.add(parametrization); // not a Collection
        facts.addAll(buildingList);
        facts.addAll(computerList);
        ...
        return facts;
    }

}
----

After in `*.java`:
[source, java]
----
@PlanningSolution
public class CloudBalance {

    @ProblemFactProperty
    private CloudParametrization parametrization;
    @ProblemFactCollectionProperty
    private List<CloudBuilding> buildingList;
    @ValueRangeProvider(id = "computerRange")
    @ProblemFactCollectionProperty
    private List<CloudComputer> computerList;
    ...

}
----

Don't add the `@ProblemFactCollectionProperty` annotation on getters (or fields)
that have a `@PlanningEntityCollectionProperty` annotation.

[.upgrade-recipe-major]
=== `SolutionFileIO`: added optional generic type parameter

To avoid the awkward cast to your `Solution` implementation and to get rid of that deprecated interface,
`SolutionFileIO` now optionally supports a generic type parameter (which is the solution class).

Before in `*.java`:
[source, java]
----
public class TspFileIO implements SolutionFileIO {
    ...

    public Solution read(File inputSolutionFile) {...}

    public void write(Solution solution, File outputSolutionFile) {
        TspSolution tspSolution = (TspSolution) solution;
        ...
    }

}
----

After in `*.java`:
[source, java]
----
public class TspFileIO implements SolutionFileIO<TspSolution> {
    ...

    public TspSolution read(File inputSolutionFile) {...}

    public void write(TspSolution tspSolution, File outputSolutionFile) {
        ...
    }

}
----

[.upgrade-recipe-minor]
=== `XStreamSolutionFileIO`: added optional generic type parameter

To avoid the awkward cast to your `Solution` implementation and to get rid of that deprecated interface,
`XStreamSolutionFileIO` now optionally supports a generic type parameter (which is the solution class).

Before in `*.java`:
[source, java]
----
SolutionFileIO solutionFileIO = new XStreamSolutionFileIO(CloudBalance.class);
----

After in `*.java`:
[source, java]
----
SolutionFileIO<CloudBalance> solutionFileIO = new XStreamSolutionFileIO<>(CloudBalance.class);
----

[.upgrade-recipe-minor]
=== `CustomPhaseCommand`: added optional generic type parameter

To avoid the awkward cast to your `Solution` implementation and to get rid of that deprecated interface,
`CustomPhaseCommand` now optionally supports a generic type parameter (which is the solution class).

Before in `*.java`:
[source, java]
----
public class DinnerPartySolutionInitializer extends AbstractCustomPhaseCommand {

    public void changeWorkingSolution(ScoreDirector scoreDirector) {
        DinnerParty dinnerParty = (DinnerParty) scoreDirector.getWorkingSolution();
        ...
    }

}
----

After in `*.java`:
[source, java]
----
public class DinnerPartySolutionInitializer extends AbstractCustomPhaseCommand<DinnerParty> {

    public void changeWorkingSolution(ScoreDirector<DinnerParty> scoreDirector) {
        DinnerParty dinnerParty = scoreDirector.getWorkingSolution();
        ...
    }

}
----

[.upgrade-recipe-major]
=== `ProblemFactChange`: added optional generic type parameter

To avoid the awkward cast to your `Solution` implementation and to get rid of that deprecated interface,
`ProblemFactChange` now optionally supports a generic type parameter (which is the solution class).

Before in `*.java`:
[source, java]
----
        solver.addProblemFactChange(new ProblemFactChange() {
            public void doChange(ScoreDirector scoreDirector) {
                CloudBalance cloudBalance = (CloudBalance) scoreDirector.getWorkingSolution();
                ...
            }
        });
----

After in `*.java`:
[source, java]
----
        solver.addProblemFactChange(new ProblemFactChange<CloudBalance>() {
            public void doChange(ScoreDirector<CloudBalance> scoreDirector) {
                CloudBalance cloudBalance = scoreDirector.getWorkingSolution();
                ...
            }
        });
----

After in `*.java` (with lamdba):
[source, java]
----
        solver.addProblemFactChange(scoreDirector -> {
            CloudBalance cloudBalance = scoreDirector.getWorkingSolution();
            ...
        });
----





[.upgrade-recipe-minor]
=== `Bendable*Score`: `toString()` changed

A bendable score (`BendableScore`, `BendableLongScore` or `BendableBigDecimalScore`) 's `String`
has changed so it can be parsed without the ScoreDefinition

Before in `*SolverConfig.xml` and `*BenchmarkConfig.xml`:
[source, xml]
----
      <termination>
        <bestScoreLimit>0/0/-1/-2/-3</bestScoreLimit>
      </termination>
----

After in `*SolverConfig.xml` and `*BenchmarkConfig.xml`:
[source, xml]
----
      <termination>
        <bestScoreLimit>[0/0]hard/[-1/-2/-3]soft</bestScoreLimit>
      </termination>
----

Before in XStream `*.xml` output with `optaplanner-persistence-xstream`:
[source, xml]
----
      <score>0/0/-1/-2/-3</score>
----

After in in XStream `*.xml` output with `optaplanner-persistence-xstream`:
[source, xml]
----
      <score>[0/0]hard/[-1/-2/-3]soft</score>
----


[.upgrade-recipe-major]
=== `EnvironmentMode`: `PRODUCTION` renamed

The `EnvironmentMode` `PRODUCTION` has been renamed to `NON_REPRODUCIBLE`
because most enterprises use `REPRODUCIBLE` in production.
For backwards compatibility, `PRODUCTION` still exists, but it's deprecated and will be removed in a future version.

Before in `*SolverConfig.xml` and `*BenchmarkConfig.xml`:
[source, xml]
----
<solver>
  <environmentMode>PRODUCTION</environmentMode>
  ...
</solver>
----

After in `*SolverConfig.xml` and `*BenchmarkConfig.xml`:
[source, xml]
----
<solver>
  <environmentMode>NON_REPRODUCIBLE</environmentMode>
  ...
</solver>
----


[.upgrade-recipe-readme]
=== Average calculate count renamed to score calculation speed

In the logs and the benchmark report, the _average calculate count per second_ has been renamed to _score calculation speed_.


[.upgrade-recipe-minor]
=== `Termination`: `calculateCountLimit` renamed

The termination configuration property `calculateCountLimit` has been renamed to `scoreCalculationCountLimit`.

Before in `*SolverConfig.xml` and `*BenchmarkConfig.xml`:
[source, xml]
----
  <termination>
    <calculateCountLimit>100000</calculateCountLimit>
  </termination>
----

After in `*SolverConfig.xml` and `*BenchmarkConfig.xml`:
[source, xml]
----
  <termination>
    <scoreCalculationCountLimit>100000</scoreCalculationCountLimit>
  </termination>
----


[.upgrade-recipe-minor]
=== `ProblemStatisticType`: `CALCULATE_COUNT_PER_SECOND` renamed

The benchmark ProblemStatisticType `SCORE_CALCULATION_SPEED` has been renamed to `SCORE_CALCULATION_SPEED`.

Before in `*BenchmarkConfig.xml`:
[source, xml]
----
      <problemStatisticType>CALCULATE_COUNT_PER_SECOND</problemStatisticType>
----

After in `*BenchmarkConfig.xml`:
[source, xml]
----
      <problemStatisticType>SCORE_CALCULATION_SPEED</problemStatisticType>
----


[.upgrade-recipe-readme]
=== `Score`: uninitialized variable count

A solution's `Score` now also contains the number of uninitialized variables (usually `0`) as a negative `getInitScore()`.
This is useful in exotic cases with multiple phases to fully initialize a solution.
It also prevents bugs in multi-threaded use cases.

With `Score.isSolutionInitialized()`, it's now possible to quickly and reliably determine if a solution is fully initialized.
The method `FeasibleScore.isFeasible()` now also checks if the solution was fully initialized during score calculation.


----[.upgrade-recipe-major]
=== `Score`: `valueOf(...)` changed and `valueOfInitialized(...)` added



Before in `*.java`:
[source, java]
----
        SimpleScore score = SimpleScore.valueOf(1234);

----

After in `*.java`:
[source, java]
----
        SimpleScore score = SimpleScore.valueOfInitialized(1234);
----

Before in `*.java`:
[source, java]
----
        HardSoftScore score = HardSoftScore.valueOf(1200, 34);

----

After in `*.java`:
[source, java]
----
        HardSoftScore score = HardSoftScore.valueOfInitialized(1200, 34);
----


[.upgrade-recipe-major]
=== `BestSolutionChangedEvent`: `isNewBestSolutionInitialized()` replaced

The method `BestSolutionChangedEvent.isNewBestSolutionInitialized()`
has been deprecated in favor of `BestSolutionChangedEvent.getNewBestSolution().getScore().isSolutionInitialized()`.

Before in `*.java`:
[source, java]
----
    public void bestSolutionChanged(BestSolutionChangedEvent<CloudBalance> event) { // In solver thread
        if (event.isEveryProblemFactChangeProcessed()
                && event.isNewBestSolutionInitialized()) {
            ...
        }
    }
----

After in `*.java`:
[source, java]
----
    public void bestSolutionChanged(BestSolutionChangedEvent<CloudBalance> event) { // In solver thread
        if (event.isEveryProblemFactChangeProcessed()
                && event.getNewBestSolution().getScore().isSolutionInitialized()) {
            ...
        }
    }
----

However, if you also check `isFeasible()`, that suffices because it now guarantees the solution is initialized.

After in `*.java` for a `FeasibleScore`:
[source, java]
----
    public void bestSolutionChanged(BestSolutionChangedEvent<CloudBalance> event) { // In solver thread
        if (event.isEveryProblemFactChangeProcessed()
                && event.getNewBestSolution().getScore().isFeasible()) { // isFeasible() checks isSolutionInitialized() too
            ...
        }
    }
----


----[.upgrade-recipe-minor]
=== `Score` and `ScoreDefinition`: methods changed

The `ScoreDefinition.fromLevelNumbers(...)` method now requires an `initScore` parameter.

Before in `*.java`:
[source, java]
----
Score score = scoreDefinition.fromLevelNumbers(new int[]{0, -200});
----

After in `*.java` (quick and dirty fix):
[source, java]
----
Score score = scoreDefinition.fromLevelNumbers(0, new int[]{0, -200});
----

The `Score.negate()` method is now deprecated.


[.upgrade-recipe-minor]
=== Custom `Score`: methods added

If you have a custom `Score`:
The `Score` interface has several new methods: `getInitScore()`, `isSolutionInitialized()` and `toInitializedScore()`.
The first two methods are implemented by `AbstractScore`, but the last one is implementation specific.

Before in `*.java`:
[source, java]
----
public final class HardSoftScore extends AbstractScore<HardSoftScore> ... {
    ...
}
----

After in `*.java`:
[source, java]
----
public final class HardSoftScore extends AbstractScore<HardSoftScore> ... {
    ...

    public HardSoftScore toInitializedScore() {
        return initScore == 0 ? this : new HardSoftScore(0, hardScore, softScore);
    }

}
----






----[.upgrade-recipe-minor]
=== Hibernate integration: extra `@Column` needed

Because a `Score` now also contains an `initScore` of type `int` (regardless of the type of the other fields),
add an extra `@Column` annotation to the beginning of the `@Columns` list to map that field to a database column.

Set it to `0` for all existing records (unless you have reason to believe that some scores weren't calculated on a fully initialized solution).

Before in `*.java`:
[source, java]
----
        @Columns(columns = {@Column(name = "hardScore"), @Column(name = "softScore")})
        public HardSoftScore getScore() {
            return score;
        }
----

After in `*.java`:
[source, java]
----
        @Columns(columns = {@Column(name = "initScore"), @Column(name = "hardScore"), @Column(name = "softScore")})
        public HardSoftScore getScore() {
            return score;
        }
----
