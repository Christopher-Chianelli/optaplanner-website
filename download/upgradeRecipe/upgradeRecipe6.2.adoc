= Upgrade recipe 6.2
:awestruct-description: Upgrade to OptaPlanner 6.2 from a previous version.
:awestruct-layout: upgradeRecipeBase
:awestruct-priority: 0.5
:awestruct-upgrade_recipe_version: 6.2
:awestruct-upgrade_recipe_previous_version: 6.1
:icons: font

== From 6.1.0.Final to 6.2.0.Beta1

=== icon:info-circle[] Minor

[.hidden-section]
====
If you have a custom `ScoreDefinition`: the methods `ScoreHolder.register*ConstraintMatch` have been refactored.

Before in `*.java`:
[source, java]
----
public void addConstraintMatch(RuleContext kcontext, final int weight) {
    ...
    registerIntConstraintMatch(kcontext, 0, weight, new Runnable() {
        public void run() {
            ...
        }
    });
}
----

After in `*.java`:
[source, java]
----
public void addConstraintMatch(RuleContext kcontext, final int weight) {
    ...
    registerIntConstraintMatch(kcontext, 0, weight, new IntConstraintUndoListener() {
        public void undo() {
            ...
        }
    });
}
----

====

=== icon:exclamation-circle[] Major

====
If you have a custom `Move` implementation, now extract `AbstractMove`

Before in `*.java`:
[source, java]
----
public class CloudComputerChangeMove implements Move {...}
----

After in `*.java`:
[source, java]
----
public class CloudComputerChangeMove extends AbstractMove {...}
----

====

=== icon:info-circle[] Minor

[.hidden-section]
====
The interface `Move` has a new method `getSimpleMoveTypeDescription()`.
Extend `AbstractMove` so to avoid having to implement it.

====

=== icon:info-circle[] Minor

[.hidden-section]
====
If you have a `@ValueRangeProvider` on an entity class (instead of the `Solution` class),
then it's now safe to use the `<pillarChangeMoveSelector>` and `<pillarSwapMoveSelector>` as is.
It's no longer needed to filter out swaps or changes
which could put a value in an entity's variable that's not in its value range.

Before in `*SolverConfig.xml` and `*BenchmarkConfig.xml`:
[source, xml]
----
  <pillarChangeMoveSelector>
    <filterClass>...ValidChangesOnlyPillarChangeMoveFilter</filterClass>
  </pillarChangeMoveSelector>
  <pillarSwapMoveSelector>
    <filterClass>...ValidSwapsOnlyPillarSwapMoveFilter</filterClass>
  </pillarSwapMoveSelector>
----

After in `*SolverConfig.xml` and `*BenchmarkConfig.xml`:
[source, xml]
----
  <pillarChangeMoveSelector/>
  <pillarSwapMoveSelector/>
----

====

=== icon:info-circle[] Minor

[.hidden-section]
====
`ConstraintMatchTotal` are now naturally compared by `scoreLevel`, then `constraintPackage`, then `constraintName`
(instead of by `constraintPackage`, then `constraintName`, then `scoreLevel`) for readability.

====

=== icon:info-circle[] Minor

[.hidden-section]
====
The optional method `IncrementalScoreCalculator.buildScoreCorruptionAnalysis(IncrementalScoreCalculator)` has been removed.
Instead, to get a pretty score corruption analysis, implement the new interface `ConstraintMatchAwareIncrementalScoreCalculator`.
This also enable your GUI to explain the score with an `IncrementalScoreCalculator`.
See the example code in `MachineReassignmentIncrementalScoreCalculator.getConstraintMatchTotals()`.

====

== From 6.2.0.Beta1 to 6.2.0.Beta2

=== icon:info-circle[] Minor

[.hidden-section]
====
The element `<deciderScoreComparatorFactory>` (which was deprecated, not documented, broken and clearly marked as not backwards compatible) has been removed.
Instead, use strategic oscillation.

Before in `*SolverConfig.xml` and `*BenchmarkConfig.xml`:
[source, xml]
----
  <localSearch>
...
<forager>
  ...
  <deciderScoreComparatorFactory>
    ...
  </deciderScoreComparatorFactory>
</forager>
  </localSearch>
----

After in `*SolverConfig.xml` and `*BenchmarkConfig.xml`:
[source, xml]
----
  <localSearch>
...
<forager>
  ...
  <finalistPodiumType>STRATEGIC_OSCILLATION</finalistPodiumType>
</forager>
  </localSearch>
----

====

=== icon:user-secret[] Implementation detail

[.hidden-section]
====
The `ScoreBounder` methods `calculateOptimisticBound()` and `calculatePessimisticBound()`
no longer have an `uninitializedVariableCount` parameter.
Instead, if all the variables for a branch and bound algorithm are initialized,
those methods are no called to determine the bounds (because the bound is the working score).
If the `uninitializedVariableCount` is still needed for some reason, use the `ScoreDirector` to calculate it accurately.

====

=== icon:info-circle[] Minor

[.hidden-section]
====
Before calling `ScoreDirector.getConstraintMatchTotals()`, it's no longer expected to call `ScoreDirector.calculateScore()` first.

====

== From 6.2.0.CR1 to 6.2.0.CR2

=== icon:info-circle[] Minor

[.hidden-section]
====
`CompositeMove` now uses a `Move` array instead of a `List<Move>` for performance reasons.

Before in `*.java`:
[source, java]
----
... = CompositeMove.buildMove(Arrays.asList(moveA, moveB, ...));
----

After in `*.java`:
[source, java]
----
... = CompositeMove.buildMove(moveA, moveB, ...);
----

Before in `*.java`:
[source, java]
----
... = new CompositeMove(moveList); // Not recommended
----

After in `*.java`:
[source, java]
----
... = new CompositeMove(moves); // Not recommended
----

====

=== icon:user-secret[] Implementation detail

[.hidden-section]
====
`InverseRelationShadowVariableListener` renamed to `SingletonInverseVariableListener`.
It and `InverseRelationShadowVariableDescriptor` moved to the package `...impl.domain.variable.inverserelation`.

====

== From 6.2.0.CR3 to 6.2.0.CR4

=== icon:exclamation-circle[] Major

====
There is now out-of-the-box support for a shadow variable representing the anchor of a chained variable.
For example, in a VRP each `Customer` (= entity) needs to know to which `Vehicle` (= anchor) it belongs.
This declarative support allows build-in selectors to reuse that knowledge without duplicating the calculation.

Before in `*.java`:
[source, java]
----
@PlanningEntity
public class Customer implements Standstill {
    @PlanningVariable(...)
    public Standstill getPreviousStandstill() {...}
    @CustomShadowVariable(variableListenerClass = VehicleUpdatingVariableListener.class,
            sources = {@CustomShadowVariable.Source(variableName = "previousStandstill")})
    public Vehicle getVehicle() {...}
}
public class VehicleUpdatingVariableListener implements VariableListener<Customer> {
    ...
}
----

After in `*.java`:
[source, java]
----
@PlanningEntity
public class Customer implements Standstill {
    @PlanningVariable(...)
    public Standstill getPreviousStandstill() {...}
    @AnchorShadowVariable(sourceVariableName = "previousStandstill")
    public Vehicle getVehicle() {...}
}
----

====

== From 6.2.0.CR4 to 6.2.0.Final

=== icon:info-circle[] Minor

[.hidden-section]
====
The undocumented, experimental `<twoOptMoveSelector>` has been replaced by `<tailChainSwapMoveSelector>`,
which is documented.

====

=== icon:book[] Readme

====
To scale VRP cases, Nearby Selection is critical. It is now finally completely supported and documented.
====

